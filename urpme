#!/usr/bin/perl

# $Id$

#- Copyright (C) 1999, 2000, 2001, 2002, 2003, 2004, 2005 MandrakeSoft SA
#- Copyright (C) 2005, 2006 Mandriva SA
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2, or (at your option)
# any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.

use strict;
use urpm;
use urpm::args;
use urpm::msg;
use urpm::install;
use urpm::media;
use urpm::select;


$ENV{PATH} = "/sbin:/usr/sbin:/bin:/usr/bin:/usr/X11R6/bin";
delete @ENV{qw(ENV BASH_ENV IFS CDPATH)};

our ($test, $parallel, $auto, $matches, $force, $noscripts, $repackage, $restricted);
my $yesexpr =
  #-PO: Add here the keys which might be pressed in the "Yes"-case.
  N("Yy");

sub usage() {
    print N("urpme version %s
Copyright (C) 1999-2008 Mandriva.
This is free software and may be redistributed under the terms of the GNU GPL.

usage:
", $urpm::VERSION) . N("  --help         - print this help message.
") . N("  --auto         - automatically select a package in choices.
") . N("  --test         - verify if the removal can be achieved correctly.
") . N("  --force        - force invocation even if some packages do not exist.
") . N("  --parallel     - distributed urpmi across machines of alias.
") . N("  --repackage    - Re-package the files before erasing
") . N("  --root         - use another root for rpm removal.
") . N("  --urpmi-root   - use another root for urpmi db & rpm installation.
") . N("  --noscripts    - do not execute package scriptlet(s).
") . N("  --use-distrib  - configure urpme on the fly from a distrib tree, useful
                   to (un)install a chroot with --root option.
") . N("  --verbose, -v  - verbose mode.
") . N("  -a             - select all packages matching expression.
");
    exit(1);
}

@ARGV or usage();
my @origARGV = @ARGV;
my $urpm = urpm->new_parse_cmdline or exit(1);
my @cmdline_pkgs_to_remove = @ARGV;

my $state = {};

if ($< && !$test) {
    $urpm->{fatal}(1, N("Only superuser is allowed to remove packages"));
}

#- rurpme checks
if ($restricted) {
    urpm::error_restricted($urpm) if $urpm->{root} || $options{usedistrib} || $noscripts || $parallel;
}

unless ($test) {
    sys_log("called with: @origARGV");
}

#- just configure parallel mode if available.
my $_urpmi_lock = urpm::lock::urpmi_db($urpm, '', wait => $options{wait_lock});
urpm::media::configure($urpm,
    synthesis => ($parallel ? 'none' : ''),
    parallel => $parallel,
    probe_with => $options{probe_with},
    usedistrib => $options{usedistrib},
);

#- examine packages...
my @toremove = urpm::select::find_packages_to_remove($urpm,
    $state,
    \@cmdline_pkgs_to_remove,
    matches => $matches,
    force => $force,
    callback_notfound => sub {
	my $urpm = shift @_;
	#- Warning : the following message is parsed in urpm::parallel_*
	$urpm->{fatal}(1, (@_ > 1 ? N("unknown packages") : N("unknown package")) .
	    ': ' . join(', ', @_)); 0 },
    callback_fuzzy => sub {
	my $urpm = shift @_;
	my $match = shift @_;
	my $pkgs = $urpm::msg::no_translation ? join(' ', @_) : join('', map { "\n$_" } sort @_);
	#- Warning : the following message is parsed in urpm::parallel_*
	$urpm->{fatal}(1, N("The following packages contain %s: %s", $match, $pkgs)); 
	0 },
    callback_base => sub {
	my $urpm = shift @_;
	foreach (@_) {
	    #- Warning : the following message is parsed in urpm::parallel_*
	    $urpm->{error}(N("removing package %s will break your system", $_));
	} 0 },
) or $urpm->{fatal}(0, N("Nothing to remove"));

my $list = urpm::select::translate_why_removed($urpm, $state, @toremove);
if ($test && $auto) {
    #- Warning : the following message is parsed in urpm::parallel_*
    my $msg = N("Checking to remove the following packages");
    print STDOUT "$msg:\n$list\n";
} elsif (($parallel || @toremove > @cmdline_pkgs_to_remove) && !$auto) {
    my $msg = 
    P("To satisfy dependencies, the following package will be removed",
    "To satisfy dependencies, the following %d packages will be removed",
    scalar(@toremove), scalar(@toremove)) . sprintf(" (%s)", formatXiB(-$urpm->selected_size($state)));
    print STDOUT "$msg:\n$list\n";
    $force || message_input_(P("Remove %d package?", "Remove %d packages?", scalar(@toremove), scalar(@toremove)) . N(" (y/N) "), boolean => 1) =~ /[$yesexpr]/ or exit 0;
}

#- Warning : the following message is parsed in urpm::parallel_*
print N("removing %s", join(' ', sort @toremove)) . "\n";
my @errors = $parallel
    ? urpm::parallel::remove($urpm,
	\@toremove,
	test => $test,
	force => $force,
	noscripts => $noscripts,
	repackage => $repackage || $urpm->{options}{repackage},
    )
    : urpm::install::install($urpm,
	\@toremove, {}, {},
	test => $test,
	force => $force,
	noscripts => $noscripts,
	repackage => $repackage || $urpm->{options}{repackage},
    );

if (@errors) {
    #- Warning : the following message is parsed in urpm::parallel_*
    $urpm->{fatal}(2, N("Removal failed") . ":\n" . join("\n",  map { "\t$_" } @errors));
}
